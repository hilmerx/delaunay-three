<!DOCTYPE html>
<html>
  <head>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/three.js/90/three.min.js"></script>
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script src="https://github.com/processing/p5.js/releases/download/0.6.0/p5.min.js"></script>
    <script src="noise.js"></script>


  </head>

  <body>
    <canvas id="canvas" width="1024" height="1024">
    </canvas>

    <script type="text/javascript" src="delaunay.js">
    </script>

    <script type="text/javascript">
        var noise = new Noise(Math.random())
        var canvas = document.getElementById("canvas"),
            ctx = canvas.getContext("2d"),
              // vertices = new Array(10),
              vertices = new Array(1024),
              i, x, y;

        for(i = vertices.length; i--; ) {
            do {
                x = Math.random() - 0.5;
                y = Math.random() - 0.5;
            } while(x * x + y * y > 0.25);

            x = (x * 0.96875 + 0.5) * canvas.width;
            y = (y * 0.96875 + 0.5) * canvas.height;

            vertices[i] = [x, y];
        }
        var triangles1D = Delaunay.triangulate(vertices);
        let triangles = []

        for(i = triangles1D.length; i; ) {
            let buffer = []
            ctx.beginPath();
            --i; ctx.moveTo(vertices[triangles1D[i]][0], vertices[triangles1D[i]][1]);
            buffer.push({
              x:vertices[triangles1D[i]][0],
              y:vertices[triangles1D[i]][1]
            })

            --i; ctx.lineTo(vertices[triangles1D[i]][0], vertices[triangles1D[i]][1]);
            buffer.push({
              x:vertices[triangles1D[i]][0],
              y:vertices[triangles1D[i]][1]
            })

            --i; ctx.lineTo(vertices[triangles1D[i]][0], vertices[triangles1D[i]][1]);
            buffer.push({
              x:vertices[triangles1D[i]][0],
              y:vertices[triangles1D[i]][1]
            })

            ctx.closePath();
            ctx.stroke();
            triangles.push(buffer)
          }

          var scene = new THREE.Scene();
          var camera = new THREE.PerspectiveCamera(35, window.innerWidth/window.innerHeight, 0.1, 3000);

          var controls = new THREE.OrbitControls( camera )

          var renderer = new THREE.WebGLRenderer();
          renderer.setSize(window.innerWidth, window.innerHeight);
          document.body.appendChild(renderer.domElement);

        let vertPairs = []
        vertices.forEach(v=>{ 
            vertPairs.push({
                x:v[0],
                y:v[1],
                matches: []
            })
        })

        vertPairs.forEach(v => {
            for (var i = 0; i < triangles.length; i++) {
                for (var j = 0; j < triangles[i].length; j++) {
                    if(v.x === triangles[i][j].x && v.y === triangles[i][j].y){
                        v.matches.push([i, j])
                    }
                }
            }
        })



        function makeZ(){
            vertPairs.forEach(vert =>{
                let div, z
                div = 400
                z = noise.perlin2(vert.x / div, vert.y / div) * 100
                div = 800
                z = noise.perlin2(vert.x / div, vert.y / div) * 200 + z
                div = 150
                z = noise.perlin2(vert.x / div, vert.y / div) * 50 + z
                vert.matches.forEach(m=>{
                    triangles[m[0]][m[1]].z = z
                })
            })
        }
        // makeZ()


        triangles.forEach(tri => {
            tri.forEach(vert => {
                let div = 300
                vert.z = noise.perlin2(vert.x / div, vert.y / div) * 100
            })
        })

      function makeTriangle(tri){
        var off = -500
        var meshMaterial = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});

        var geom = new THREE.Geometry(); 
        var v1 = new THREE.Vector3(tri[0].x + off,tri[0].y + off, tri[0].z);
        var v2 = new THREE.Vector3(tri[1].x + off,tri[1].y + off, tri[1].z);
        var v3 = new THREE.Vector3(tri[2].x + off,tri[2].y + off, tri[2].z);


        geom.vertices.push(v1);
        geom.vertices.push(v2);
        geom.vertices.push(v3);


        geom.faces.push( new THREE.Face3( 0, 1, 2 ) );


        var object = new THREE.Mesh( geom, meshMaterial);
        object.doubleSided = true;
        scene.add(object);
      }

      var light1 = new THREE.AmbientLight( 0x888888 ); 
      scene.add( light1 );

        var light2 = new THREE.PointLight( 0xffffff, 1, 100 );
        light2.position.set( 50, 50, 50 );
        scene.add( light2 );

      triangles.forEach(tri => {
        makeTriangle(tri)
        // console.log(tri);
      })
      let test = [{x:0,y:1},{x:0,y:0},{x:1,y:1}]



      var geometry = new THREE.BoxGeometry(1,1,2);
      var material = new THREE.MeshLambertMaterial({color: Math.random() * 0xffffff});
      var cube = new THREE.Mesh(geometry, material);
      // scene.add(cube);

      camera.position.z = 2000;
      var render = function () {
        // camera.position.set( 0, 20, 100 );
        controls.update();

      requestAnimationFrame(render);
      // camera.rotation.y += 0.003;
      // camera.rotation. += 0.003;
      renderer.render(scene, camera);
      }
      render();

    </script>
  </body>
</html>
